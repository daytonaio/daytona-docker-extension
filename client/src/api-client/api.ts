/* tslint:disable */
/* eslint-disable */
/**
 * Daytona Server API
 * Daytona Server API
 *
 * The version of the OpenAPI document: v0.0.0-dev
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base'

/**
 *
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
  /**
   *
   * @type {string}
   * @memberof ApiKey
   */
  keyHash: string
  /**
   * Project or client name
   * @type {string}
   * @memberof ApiKey
   */
  name: string
  /**
   *
   * @type {ApikeyApiKeyType}
   * @memberof ApiKey
   */
  type: ApikeyApiKeyType
}

/**
 *
 * @export
 * @enum {string}
 */

export const ApikeyApiKeyType = {
  ApiKeyTypeClient: 'client',
  ApiKeyTypeProject: 'project',
  ApiKeyTypeWorkspace: 'workspace',
} as const

export type ApikeyApiKeyType =
  (typeof ApikeyApiKeyType)[keyof typeof ApikeyApiKeyType]

/**
 *
 * @export
 * @interface ContainerRegistry
 */
export interface ContainerRegistry {
  /**
   *
   * @type {string}
   * @memberof ContainerRegistry
   */
  password: string
  /**
   *
   * @type {string}
   * @memberof ContainerRegistry
   */
  server: string
  /**
   *
   * @type {string}
   * @memberof ContainerRegistry
   */
  username: string
}
/**
 *
 * @export
 * @interface CreateProjectConfigDTO
 */
export interface CreateProjectConfigDTO {
  /**
   *
   * @type {ProjectBuildConfig}
   * @memberof CreateProjectConfigDTO
   */
  buildConfig?: ProjectBuildConfig
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CreateProjectConfigDTO
   */
  envVars: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof CreateProjectConfigDTO
   */
  image?: string
  /**
   *
   * @type {string}
   * @memberof CreateProjectConfigDTO
   */
  name: string
  /**
   *
   * @type {CreateProjectConfigSourceDTO}
   * @memberof CreateProjectConfigDTO
   */
  source: CreateProjectConfigSourceDTO
  /**
   *
   * @type {string}
   * @memberof CreateProjectConfigDTO
   */
  user?: string
}
/**
 *
 * @export
 * @interface CreateProjectConfigSourceDTO
 */
export interface CreateProjectConfigSourceDTO {
  /**
   *
   * @type {GitRepository}
   * @memberof CreateProjectConfigSourceDTO
   */
  repository: GitRepository
}
/**
 *
 * @export
 * @interface CreateWorkspaceDTO
 */
export interface CreateWorkspaceDTO {
  /**
   *
   * @type {string}
   * @memberof CreateWorkspaceDTO
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof CreateWorkspaceDTO
   */
  name: string
  /**
   *
   * @type {Array<CreateProjectConfigDTO>}
   * @memberof CreateWorkspaceDTO
   */
  projects: Array<CreateProjectConfigDTO>
  /**
   *
   * @type {string}
   * @memberof CreateWorkspaceDTO
   */
  target: string
}
/**
 *
 * @export
 * @interface DevcontainerConfig
 */
export interface DevcontainerConfig {
  /**
   *
   * @type {string}
   * @memberof DevcontainerConfig
   */
  filePath: string
}
/**
 *
 * @export
 * @interface FRPSConfig
 */
export interface FRPSConfig {
  /**
   *
   * @type {string}
   * @memberof FRPSConfig
   */
  domain: string
  /**
   *
   * @type {number}
   * @memberof FRPSConfig
   */
  port: number
  /**
   *
   * @type {string}
   * @memberof FRPSConfig
   */
  protocol: string
}
/**
 *
 * @export
 * @interface FileStatus
 */
export interface FileStatus {
  /**
   *
   * @type {string}
   * @memberof FileStatus
   */
  extra: string
  /**
   *
   * @type {string}
   * @memberof FileStatus
   */
  name: string
  /**
   *
   * @type {Status}
   * @memberof FileStatus
   */
  staging: Status
  /**
   *
   * @type {Status}
   * @memberof FileStatus
   */
  worktree: Status
}

/**
 *
 * @export
 * @interface GitBranch
 */
export interface GitBranch {
  /**
   *
   * @type {string}
   * @memberof GitBranch
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof GitBranch
   */
  sha: string
}
/**
 *
 * @export
 * @interface GitNamespace
 */
export interface GitNamespace {
  /**
   *
   * @type {string}
   * @memberof GitNamespace
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof GitNamespace
   */
  name: string
}
/**
 *
 * @export
 * @interface GitProvider
 */
export interface GitProvider {
  /**
   *
   * @type {string}
   * @memberof GitProvider
   */
  baseApiUrl?: string
  /**
   *
   * @type {string}
   * @memberof GitProvider
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof GitProvider
   */
  token: string
  /**
   *
   * @type {string}
   * @memberof GitProvider
   */
  username: string
}
/**
 *
 * @export
 * @interface GitPullRequest
 */
export interface GitPullRequest {
  /**
   *
   * @type {string}
   * @memberof GitPullRequest
   */
  branch: string
  /**
   *
   * @type {string}
   * @memberof GitPullRequest
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof GitPullRequest
   */
  sha: string
  /**
   *
   * @type {string}
   * @memberof GitPullRequest
   */
  sourceRepoId: string
  /**
   *
   * @type {string}
   * @memberof GitPullRequest
   */
  sourceRepoName: string
  /**
   *
   * @type {string}
   * @memberof GitPullRequest
   */
  sourceRepoOwner: string
  /**
   *
   * @type {string}
   * @memberof GitPullRequest
   */
  sourceRepoUrl: string
}
/**
 *
 * @export
 * @interface GitRepository
 */
export interface GitRepository {
  /**
   *
   * @type {string}
   * @memberof GitRepository
   */
  branch?: string
  /**
   *
   * @type {string}
   * @memberof GitRepository
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof GitRepository
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof GitRepository
   */
  owner: string
  /**
   *
   * @type {string}
   * @memberof GitRepository
   */
  path?: string
  /**
   *
   * @type {number}
   * @memberof GitRepository
   */
  prNumber?: number
  /**
   *
   * @type {string}
   * @memberof GitRepository
   */
  sha: string
  /**
   *
   * @type {string}
   * @memberof GitRepository
   */
  source: string
  /**
   *
   * @type {string}
   * @memberof GitRepository
   */
  url: string
}
/**
 *
 * @export
 * @interface GitStatus
 */
export interface GitStatus {
  /**
   *
   * @type {string}
   * @memberof GitStatus
   */
  currentBranch: string
  /**
   *
   * @type {Array<FileStatus>}
   * @memberof GitStatus
   */
  fileStatus: Array<FileStatus>
}
/**
 *
 * @export
 * @interface GitUser
 */
export interface GitUser {
  /**
   *
   * @type {string}
   * @memberof GitUser
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof GitUser
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof GitUser
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof GitUser
   */
  username: string
}
/**
 *
 * @export
 * @interface InstallProviderRequest
 */
export interface InstallProviderRequest {
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof InstallProviderRequest
   */
  downloadUrls: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof InstallProviderRequest
   */
  name: string
}
/**
 *
 * @export
 * @interface NetworkKey
 */
export interface NetworkKey {
  /**
   *
   * @type {string}
   * @memberof NetworkKey
   */
  key: string
}
/**
 *
 * @export
 * @interface ProfileData
 */
export interface ProfileData {
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ProfileData
   */
  envVars: { [key: string]: string }
}
/**
 *
 * @export
 * @interface Project
 */
export interface Project {
  /**
   *
   * @type {ProjectBuildConfig}
   * @memberof Project
   */
  buildConfig?: ProjectBuildConfig
  /**
   *
   * @type {boolean}
   * @memberof Project
   */
  default: boolean
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Project
   */
  envVars: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof Project
   */
  image: string
  /**
   *
   * @type {string}
   * @memberof Project
   */
  name: string
  /**
   *
   * @type {GitRepository}
   * @memberof Project
   */
  repository: GitRepository
  /**
   *
   * @type {ProjectState}
   * @memberof Project
   */
  state?: ProjectState
  /**
   *
   * @type {string}
   * @memberof Project
   */
  target: string
  /**
   *
   * @type {string}
   * @memberof Project
   */
  user: string
  /**
   *
   * @type {string}
   * @memberof Project
   */
  workspaceId: string
}
/**
 *
 * @export
 * @interface ProjectBuildConfig
 */
export interface ProjectBuildConfig {
  /**
   *
   * @type {DevcontainerConfig}
   * @memberof ProjectBuildConfig
   */
  devcontainer?: DevcontainerConfig
}
/**
 *
 * @export
 * @interface ProjectConfig
 */
export interface ProjectConfig {
  /**
   *
   * @type {ProjectBuildConfig}
   * @memberof ProjectConfig
   */
  buildConfig?: ProjectBuildConfig
  /**
   *
   * @type {boolean}
   * @memberof ProjectConfig
   */
  default: boolean
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ProjectConfig
   */
  envVars: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof ProjectConfig
   */
  image: string
  /**
   *
   * @type {string}
   * @memberof ProjectConfig
   */
  name: string
  /**
   *
   * @type {GitRepository}
   * @memberof ProjectConfig
   */
  repository: GitRepository
  /**
   *
   * @type {string}
   * @memberof ProjectConfig
   */
  user: string
}
/**
 *
 * @export
 * @interface ProjectInfo
 */
export interface ProjectInfo {
  /**
   *
   * @type {string}
   * @memberof ProjectInfo
   */
  created: string
  /**
   *
   * @type {boolean}
   * @memberof ProjectInfo
   */
  isRunning: boolean
  /**
   *
   * @type {string}
   * @memberof ProjectInfo
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof ProjectInfo
   */
  providerMetadata?: string
  /**
   *
   * @type {string}
   * @memberof ProjectInfo
   */
  workspaceId: string
}
/**
 *
 * @export
 * @interface ProjectState
 */
export interface ProjectState {
  /**
   *
   * @type {GitStatus}
   * @memberof ProjectState
   */
  gitStatus: GitStatus
  /**
   *
   * @type {string}
   * @memberof ProjectState
   */
  updatedAt: string
  /**
   *
   * @type {number}
   * @memberof ProjectState
   */
  uptime: number
}
/**
 *
 * @export
 * @interface Provider
 */
export interface Provider {
  /**
   *
   * @type {string}
   * @memberof Provider
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof Provider
   */
  version: string
}
/**
 *
 * @export
 * @interface ProviderProviderInfo
 */
export interface ProviderProviderInfo {
  /**
   *
   * @type {string}
   * @memberof ProviderProviderInfo
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof ProviderProviderInfo
   */
  version: string
}
/**
 *
 * @export
 * @interface ProviderProviderTargetProperty
 */
export interface ProviderProviderTargetProperty {
  /**
   * DefaultValue is converted into the appropriate type based on the Type If the property is a FilePath, the DefaultValue is a path to a directory
   * @type {string}
   * @memberof ProviderProviderTargetProperty
   */
  defaultValue?: string
  /**
   * Brief description of the property
   * @type {string}
   * @memberof ProviderProviderTargetProperty
   */
  description?: string
  /**
   * A regex string matched with the name of the target to determine if the property should be disabled If the regex matches the target name, the property will be disabled E.g. \"^local$\" will disable the property for the local target
   * @type {string}
   * @memberof ProviderProviderTargetProperty
   */
  disabledPredicate?: string
  /**
   *
   * @type {boolean}
   * @memberof ProviderProviderTargetProperty
   */
  inputMasked?: boolean
  /**
   * Options is only used if the Type is ProviderTargetPropertyTypeOption
   * @type {Array<string>}
   * @memberof ProviderProviderTargetProperty
   */
  options?: Array<string>
  /**
   *
   * @type {ProviderProviderTargetPropertyType}
   * @memberof ProviderProviderTargetProperty
   */
  type?: ProviderProviderTargetPropertyType
}

/**
 *
 * @export
 * @enum {string}
 */

export const ProviderProviderTargetPropertyType = {
  ProviderTargetPropertyTypeString: 'string',
  ProviderTargetPropertyTypeOption: 'option',
  ProviderTargetPropertyTypeBoolean: 'boolean',
  ProviderTargetPropertyTypeInt: 'int',
  ProviderTargetPropertyTypeFloat: 'float',
  ProviderTargetPropertyTypeFilePath: 'file-path',
} as const

export type ProviderProviderTargetPropertyType =
  (typeof ProviderProviderTargetPropertyType)[keyof typeof ProviderProviderTargetPropertyType]

/**
 *
 * @export
 * @interface ProviderTarget
 */
export interface ProviderTarget {
  /**
   *
   * @type {string}
   * @memberof ProviderTarget
   */
  name: string
  /**
   * JSON encoded map of options
   * @type {string}
   * @memberof ProviderTarget
   */
  options: string
  /**
   *
   * @type {ProviderProviderInfo}
   * @memberof ProviderTarget
   */
  providerInfo: ProviderProviderInfo
}
/**
 *
 * @export
 * @interface RepositoryUrl
 */
export interface RepositoryUrl {
  /**
   *
   * @type {string}
   * @memberof RepositoryUrl
   */
  url: string
}
/**
 *
 * @export
 * @interface ServerConfig
 */
export interface ServerConfig {
  /**
   *
   * @type {number}
   * @memberof ServerConfig
   */
  apiPort: number
  /**
   *
   * @type {string}
   * @memberof ServerConfig
   */
  binariesPath: string
  /**
   *
   * @type {string}
   * @memberof ServerConfig
   */
  buildImageNamespace?: string
  /**
   *
   * @type {string}
   * @memberof ServerConfig
   */
  builderImage: string
  /**
   *
   * @type {string}
   * @memberof ServerConfig
   */
  builderRegistryServer: string
  /**
   *
   * @type {string}
   * @memberof ServerConfig
   */
  defaultProjectImage: string
  /**
   *
   * @type {string}
   * @memberof ServerConfig
   */
  defaultProjectUser: string
  /**
   *
   * @type {FRPSConfig}
   * @memberof ServerConfig
   */
  frps?: FRPSConfig
  /**
   *
   * @type {number}
   * @memberof ServerConfig
   */
  headscalePort: number
  /**
   *
   * @type {string}
   * @memberof ServerConfig
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof ServerConfig
   */
  localBuilderRegistryImage: string
  /**
   *
   * @type {number}
   * @memberof ServerConfig
   */
  localBuilderRegistryPort: number
  /**
   *
   * @type {string}
   * @memberof ServerConfig
   */
  logFilePath: string
  /**
   *
   * @type {string}
   * @memberof ServerConfig
   */
  providersDir: string
  /**
   *
   * @type {string}
   * @memberof ServerConfig
   */
  registryUrl: string
  /**
   *
   * @type {string}
   * @memberof ServerConfig
   */
  serverDownloadUrl: string
}
/**
 *
 * @export
 * @interface SetGitProviderConfig
 */
export interface SetGitProviderConfig {
  /**
   *
   * @type {string}
   * @memberof SetGitProviderConfig
   */
  baseApiUrl?: string
  /**
   *
   * @type {string}
   * @memberof SetGitProviderConfig
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof SetGitProviderConfig
   */
  token: string
  /**
   *
   * @type {string}
   * @memberof SetGitProviderConfig
   */
  username?: string
}
/**
 *
 * @export
 * @interface SetProjectState
 */
export interface SetProjectState {
  /**
   *
   * @type {GitStatus}
   * @memberof SetProjectState
   */
  gitStatus?: GitStatus
  /**
   *
   * @type {number}
   * @memberof SetProjectState
   */
  uptime: number
}
/**
 *
 * @export
 * @enum {string}
 */

export const Status = {
  Unmodified: 'Unmodified',
  Untracked: 'Untracked',
  Modified: 'Modified',
  Added: 'Added',
  Deleted: 'Deleted',
  Renamed: 'Renamed',
  Copied: 'Copied',
  UpdatedButUnmerged: 'Updated but unmerged',
} as const

export type Status = (typeof Status)[keyof typeof Status]

/**
 *
 * @export
 * @interface Workspace
 */
export interface Workspace {
  /**
   *
   * @type {string}
   * @memberof Workspace
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof Workspace
   */
  name: string
  /**
   *
   * @type {Array<Project>}
   * @memberof Workspace
   */
  projects: Array<Project>
  /**
   *
   * @type {string}
   * @memberof Workspace
   */
  target: string
}
/**
 *
 * @export
 * @interface WorkspaceDTO
 */
export interface WorkspaceDTO {
  /**
   *
   * @type {string}
   * @memberof WorkspaceDTO
   */
  id: string
  /**
   *
   * @type {WorkspaceInfo}
   * @memberof WorkspaceDTO
   */
  info?: WorkspaceInfo
  /**
   *
   * @type {string}
   * @memberof WorkspaceDTO
   */
  name: string
  /**
   *
   * @type {Array<Project>}
   * @memberof WorkspaceDTO
   */
  projects: Array<Project>
  /**
   *
   * @type {string}
   * @memberof WorkspaceDTO
   */
  target: string
}
/**
 *
 * @export
 * @interface WorkspaceInfo
 */
export interface WorkspaceInfo {
  /**
   *
   * @type {string}
   * @memberof WorkspaceInfo
   */
  name: string
  /**
   *
   * @type {Array<ProjectInfo>}
   * @memberof WorkspaceInfo
   */
  projects: Array<ProjectInfo>
  /**
   *
   * @type {string}
   * @memberof WorkspaceInfo
   */
  providerMetadata?: string
}

/**
 * ApiKeyApi - axios parameter creator
 * @export
 */
export const ApiKeyApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Generate an API key
     * @summary Generate an API key
     * @param {string} apiKeyName API key name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateApiKey: async (
      apiKeyName: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'apiKeyName' is not null or undefined
      assertParamExists('generateApiKey', 'apiKeyName', apiKeyName)
      const localVarPath = `/apikey/{apiKeyName}`.replace(
        `{${'apiKeyName'}}`,
        encodeURIComponent(String(apiKeyName)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List API keys
     * @summary List API keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listClientApiKeys: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apikey`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Revoke API key
     * @summary Revoke API key
     * @param {string} apiKeyName API key name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeApiKey: async (
      apiKeyName: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'apiKeyName' is not null or undefined
      assertParamExists('revokeApiKey', 'apiKeyName', apiKeyName)
      const localVarPath = `/apikey/{apiKeyName}`.replace(
        `{${'apiKeyName'}}`,
        encodeURIComponent(String(apiKeyName)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ApiKeyApi - functional programming interface
 * @export
 */
export const ApiKeyApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiKeyApiAxiosParamCreator(configuration)
  return {
    /**
     * Generate an API key
     * @summary Generate an API key
     * @param {string} apiKeyName API key name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateApiKey(
      apiKeyName: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateApiKey(
        apiKeyName,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ApiKeyApi.generateApiKey']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * List API keys
     * @summary List API keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listClientApiKeys(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKey>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listClientApiKeys(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ApiKeyApi.listClientApiKeys']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Revoke API key
     * @summary Revoke API key
     * @param {string} apiKeyName API key name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async revokeApiKey(
      apiKeyName: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.revokeApiKey(
        apiKeyName,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ApiKeyApi.revokeApiKey']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ApiKeyApi - factory interface
 * @export
 */
export const ApiKeyApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiKeyApiFp(configuration)
  return {
    /**
     * Generate an API key
     * @summary Generate an API key
     * @param {string} apiKeyName API key name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateApiKey(
      apiKeyName: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .generateApiKey(apiKeyName, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List API keys
     * @summary List API keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listClientApiKeys(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ApiKey>> {
      return localVarFp
        .listClientApiKeys(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Revoke API key
     * @summary Revoke API key
     * @param {string} apiKeyName API key name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeApiKey(
      apiKeyName: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .revokeApiKey(apiKeyName, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ApiKeyApi - object-oriented interface
 * @export
 * @class ApiKeyApi
 * @extends {BaseAPI}
 */
export class ApiKeyApi extends BaseAPI {
  /**
   * Generate an API key
   * @summary Generate an API key
   * @param {string} apiKeyName API key name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiKeyApi
   */
  public generateApiKey(apiKeyName: string, options?: RawAxiosRequestConfig) {
    return ApiKeyApiFp(this.configuration)
      .generateApiKey(apiKeyName, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List API keys
   * @summary List API keys
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiKeyApi
   */
  public listClientApiKeys(options?: RawAxiosRequestConfig) {
    return ApiKeyApiFp(this.configuration)
      .listClientApiKeys(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Revoke API key
   * @summary Revoke API key
   * @param {string} apiKeyName API key name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiKeyApi
   */
  public revokeApiKey(apiKeyName: string, options?: RawAxiosRequestConfig) {
    return ApiKeyApiFp(this.configuration)
      .revokeApiKey(apiKeyName, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ContainerRegistryApi - axios parameter creator
 * @export
 */
export const ContainerRegistryApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get container registry credentials
     * @summary Get container registry credentials
     * @param {string} server Container Registry server name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContainerRegistry: async (
      server: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'server' is not null or undefined
      assertParamExists('getContainerRegistry', 'server', server)
      const localVarPath = `/container-registry/{server}`.replace(
        `{${'server'}}`,
        encodeURIComponent(String(server)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List container registries
     * @summary List container registries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContainerRegistries: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/container-registry`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Remove a container registry credentials
     * @summary Remove a container registry credentials
     * @param {string} server Container Registry server name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeContainerRegistry: async (
      server: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'server' is not null or undefined
      assertParamExists('removeContainerRegistry', 'server', server)
      const localVarPath = `/container-registry/{server}`.replace(
        `{${'server'}}`,
        encodeURIComponent(String(server)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set container registry credentials
     * @summary Set container registry credentials
     * @param {string} server Container Registry server name
     * @param {ContainerRegistry} containerRegistry Container Registry credentials to set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setContainerRegistry: async (
      server: string,
      containerRegistry: ContainerRegistry,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'server' is not null or undefined
      assertParamExists('setContainerRegistry', 'server', server)
      // verify required parameter 'containerRegistry' is not null or undefined
      assertParamExists(
        'setContainerRegistry',
        'containerRegistry',
        containerRegistry,
      )
      const localVarPath = `/container-registry/{server}`.replace(
        `{${'server'}}`,
        encodeURIComponent(String(server)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        containerRegistry,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ContainerRegistryApi - functional programming interface
 * @export
 */
export const ContainerRegistryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ContainerRegistryApiAxiosParamCreator(configuration)
  return {
    /**
     * Get container registry credentials
     * @summary Get container registry credentials
     * @param {string} server Container Registry server name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContainerRegistry(
      server: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ContainerRegistry>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getContainerRegistry(server, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ContainerRegistryApi.getContainerRegistry']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * List container registries
     * @summary List container registries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listContainerRegistries(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ContainerRegistry>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listContainerRegistries(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ContainerRegistryApi.listContainerRegistries']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Remove a container registry credentials
     * @summary Remove a container registry credentials
     * @param {string} server Container Registry server name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeContainerRegistry(
      server: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeContainerRegistry(server, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ContainerRegistryApi.removeContainerRegistry']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Set container registry credentials
     * @summary Set container registry credentials
     * @param {string} server Container Registry server name
     * @param {ContainerRegistry} containerRegistry Container Registry credentials to set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setContainerRegistry(
      server: string,
      containerRegistry: ContainerRegistry,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setContainerRegistry(
          server,
          containerRegistry,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ContainerRegistryApi.setContainerRegistry']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ContainerRegistryApi - factory interface
 * @export
 */
export const ContainerRegistryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ContainerRegistryApiFp(configuration)
  return {
    /**
     * Get container registry credentials
     * @summary Get container registry credentials
     * @param {string} server Container Registry server name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContainerRegistry(
      server: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ContainerRegistry> {
      return localVarFp
        .getContainerRegistry(server, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List container registries
     * @summary List container registries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContainerRegistries(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ContainerRegistry>> {
      return localVarFp
        .listContainerRegistries(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Remove a container registry credentials
     * @summary Remove a container registry credentials
     * @param {string} server Container Registry server name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeContainerRegistry(
      server: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .removeContainerRegistry(server, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Set container registry credentials
     * @summary Set container registry credentials
     * @param {string} server Container Registry server name
     * @param {ContainerRegistry} containerRegistry Container Registry credentials to set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setContainerRegistry(
      server: string,
      containerRegistry: ContainerRegistry,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .setContainerRegistry(server, containerRegistry, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ContainerRegistryApi - object-oriented interface
 * @export
 * @class ContainerRegistryApi
 * @extends {BaseAPI}
 */
export class ContainerRegistryApi extends BaseAPI {
  /**
   * Get container registry credentials
   * @summary Get container registry credentials
   * @param {string} server Container Registry server name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContainerRegistryApi
   */
  public getContainerRegistry(server: string, options?: RawAxiosRequestConfig) {
    return ContainerRegistryApiFp(this.configuration)
      .getContainerRegistry(server, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List container registries
   * @summary List container registries
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContainerRegistryApi
   */
  public listContainerRegistries(options?: RawAxiosRequestConfig) {
    return ContainerRegistryApiFp(this.configuration)
      .listContainerRegistries(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Remove a container registry credentials
   * @summary Remove a container registry credentials
   * @param {string} server Container Registry server name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContainerRegistryApi
   */
  public removeContainerRegistry(
    server: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ContainerRegistryApiFp(this.configuration)
      .removeContainerRegistry(server, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Set container registry credentials
   * @summary Set container registry credentials
   * @param {string} server Container Registry server name
   * @param {ContainerRegistry} containerRegistry Container Registry credentials to set
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContainerRegistryApi
   */
  public setContainerRegistry(
    server: string,
    containerRegistry: ContainerRegistry,
    options?: RawAxiosRequestConfig,
  ) {
    return ContainerRegistryApiFp(this.configuration)
      .setContainerRegistry(server, containerRegistry, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * GitProviderApi - axios parameter creator
 * @export
 */
export const GitProviderApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get Git context
     * @summary Get Git context
     * @param {string} gitUrl Git URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGitContext: async (
      gitUrl: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'gitUrl' is not null or undefined
      assertParamExists('getGitContext', 'gitUrl', gitUrl)
      const localVarPath = `/gitprovider/context/{gitUrl}`.replace(
        `{${'gitUrl'}}`,
        encodeURIComponent(String(gitUrl)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get Git provider
     * @summary Get Git provider
     * @param {string} url Url
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGitProviderForUrl: async (
      url: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'url' is not null or undefined
      assertParamExists('getGitProviderForUrl', 'url', url)
      const localVarPath = `/gitprovider/for-url/{url}`.replace(
        `{${'url'}}`,
        encodeURIComponent(String(url)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get Git provider ID
     * @summary Get Git provider ID
     * @param {string} url Url
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGitProviderIdForUrl: async (
      url: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'url' is not null or undefined
      assertParamExists('getGitProviderIdForUrl', 'url', url)
      const localVarPath = `/gitprovider/id-for-url/{url}`.replace(
        `{${'url'}}`,
        encodeURIComponent(String(url)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get Git context
     * @summary Get Git context
     * @param {string} gitProviderId Git Provider Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGitUser: async (
      gitProviderId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'gitProviderId' is not null or undefined
      assertParamExists('getGitUser', 'gitProviderId', gitProviderId)
      const localVarPath = `/gitprovider/{gitProviderId}/user`.replace(
        `{${'gitProviderId'}}`,
        encodeURIComponent(String(gitProviderId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get Git namespaces
     * @summary Get Git namespaces
     * @param {string} gitProviderId Git provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNamespaces: async (
      gitProviderId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'gitProviderId' is not null or undefined
      assertParamExists('getNamespaces', 'gitProviderId', gitProviderId)
      const localVarPath = `/gitprovider/{gitProviderId}/namespaces`.replace(
        `{${'gitProviderId'}}`,
        encodeURIComponent(String(gitProviderId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get Git repository branches
     * @summary Get Git repository branches
     * @param {string} gitProviderId Git provider
     * @param {string} namespaceId Namespace
     * @param {string} repositoryId Repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepoBranches: async (
      gitProviderId: string,
      namespaceId: string,
      repositoryId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'gitProviderId' is not null or undefined
      assertParamExists('getRepoBranches', 'gitProviderId', gitProviderId)
      // verify required parameter 'namespaceId' is not null or undefined
      assertParamExists('getRepoBranches', 'namespaceId', namespaceId)
      // verify required parameter 'repositoryId' is not null or undefined
      assertParamExists('getRepoBranches', 'repositoryId', repositoryId)
      const localVarPath =
        `/gitprovider/{gitProviderId}/{namespaceId}/{repositoryId}/branches`
          .replace(
            `{${'gitProviderId'}}`,
            encodeURIComponent(String(gitProviderId)),
          )
          .replace(
            `{${'namespaceId'}}`,
            encodeURIComponent(String(namespaceId)),
          )
          .replace(
            `{${'repositoryId'}}`,
            encodeURIComponent(String(repositoryId)),
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get Git repository PRs
     * @summary Get Git repository PRs
     * @param {string} gitProviderId Git provider
     * @param {string} namespaceId Namespace
     * @param {string} repositoryId Repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepoPRs: async (
      gitProviderId: string,
      namespaceId: string,
      repositoryId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'gitProviderId' is not null or undefined
      assertParamExists('getRepoPRs', 'gitProviderId', gitProviderId)
      // verify required parameter 'namespaceId' is not null or undefined
      assertParamExists('getRepoPRs', 'namespaceId', namespaceId)
      // verify required parameter 'repositoryId' is not null or undefined
      assertParamExists('getRepoPRs', 'repositoryId', repositoryId)
      const localVarPath =
        `/gitprovider/{gitProviderId}/{namespaceId}/{repositoryId}/pull-requests`
          .replace(
            `{${'gitProviderId'}}`,
            encodeURIComponent(String(gitProviderId)),
          )
          .replace(
            `{${'namespaceId'}}`,
            encodeURIComponent(String(namespaceId)),
          )
          .replace(
            `{${'repositoryId'}}`,
            encodeURIComponent(String(repositoryId)),
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get Git repositories
     * @summary Get Git repositories
     * @param {string} gitProviderId Git provider
     * @param {string} namespaceId Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositories: async (
      gitProviderId: string,
      namespaceId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'gitProviderId' is not null or undefined
      assertParamExists('getRepositories', 'gitProviderId', gitProviderId)
      // verify required parameter 'namespaceId' is not null or undefined
      assertParamExists('getRepositories', 'namespaceId', namespaceId)
      const localVarPath =
        `/gitprovider/{gitProviderId}/{namespaceId}/repositories`
          .replace(
            `{${'gitProviderId'}}`,
            encodeURIComponent(String(gitProviderId)),
          )
          .replace(
            `{${'namespaceId'}}`,
            encodeURIComponent(String(namespaceId)),
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get URL from Git repository
     * @summary Get URL from Git repository
     * @param {GitRepository} repository Git repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUrlFromRepository: async (
      repository: GitRepository,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repository' is not null or undefined
      assertParamExists('getUrlFromRepository', 'repository', repository)
      const localVarPath = `/gitprovider/context/url`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        repository,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List Git providers
     * @summary List Git providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGitProviders: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/gitprovider`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Remove Git provider
     * @summary Remove Git provider
     * @param {string} gitProviderId Git provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGitProvider: async (
      gitProviderId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'gitProviderId' is not null or undefined
      assertParamExists('removeGitProvider', 'gitProviderId', gitProviderId)
      const localVarPath = `/gitprovider/{gitProviderId}`.replace(
        `{${'gitProviderId'}}`,
        encodeURIComponent(String(gitProviderId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set Git provider
     * @summary Set Git provider
     * @param {SetGitProviderConfig} gitProviderConfig Git provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGitProvider: async (
      gitProviderConfig: SetGitProviderConfig,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'gitProviderConfig' is not null or undefined
      assertParamExists(
        'setGitProvider',
        'gitProviderConfig',
        gitProviderConfig,
      )
      const localVarPath = `/gitprovider`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        gitProviderConfig,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * GitProviderApi - functional programming interface
 * @export
 */
export const GitProviderApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    GitProviderApiAxiosParamCreator(configuration)
  return {
    /**
     * Get Git context
     * @summary Get Git context
     * @param {string} gitUrl Git URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGitContext(
      gitUrl: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepository>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGitContext(
        gitUrl,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['GitProviderApi.getGitContext']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get Git provider
     * @summary Get Git provider
     * @param {string} url Url
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGitProviderForUrl(
      url: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitProvider>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getGitProviderForUrl(url, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['GitProviderApi.getGitProviderForUrl']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get Git provider ID
     * @summary Get Git provider ID
     * @param {string} url Url
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGitProviderIdForUrl(
      url: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getGitProviderIdForUrl(url, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['GitProviderApi.getGitProviderIdForUrl']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get Git context
     * @summary Get Git context
     * @param {string} gitProviderId Git Provider Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGitUser(
      gitProviderId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitUser>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGitUser(
        gitProviderId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['GitProviderApi.getGitUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get Git namespaces
     * @summary Get Git namespaces
     * @param {string} gitProviderId Git provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getNamespaces(
      gitProviderId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<GitNamespace>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaces(
        gitProviderId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['GitProviderApi.getNamespaces']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get Git repository branches
     * @summary Get Git repository branches
     * @param {string} gitProviderId Git provider
     * @param {string} namespaceId Namespace
     * @param {string} repositoryId Repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRepoBranches(
      gitProviderId: string,
      namespaceId: string,
      repositoryId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<GitBranch>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRepoBranches(
        gitProviderId,
        namespaceId,
        repositoryId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['GitProviderApi.getRepoBranches']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get Git repository PRs
     * @summary Get Git repository PRs
     * @param {string} gitProviderId Git provider
     * @param {string} namespaceId Namespace
     * @param {string} repositoryId Repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRepoPRs(
      gitProviderId: string,
      namespaceId: string,
      repositoryId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<GitPullRequest>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRepoPRs(
        gitProviderId,
        namespaceId,
        repositoryId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['GitProviderApi.getRepoPRs']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get Git repositories
     * @summary Get Git repositories
     * @param {string} gitProviderId Git provider
     * @param {string} namespaceId Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRepositories(
      gitProviderId: string,
      namespaceId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<GitRepository>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositories(
        gitProviderId,
        namespaceId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['GitProviderApi.getRepositories']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get URL from Git repository
     * @summary Get URL from Git repository
     * @param {GitRepository} repository Git repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUrlFromRepository(
      repository: GitRepository,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryUrl>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUrlFromRepository(
          repository,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['GitProviderApi.getUrlFromRepository']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * List Git providers
     * @summary List Git providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGitProviders(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<GitProvider>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listGitProviders(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['GitProviderApi.listGitProviders']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Remove Git provider
     * @summary Remove Git provider
     * @param {string} gitProviderId Git provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeGitProvider(
      gitProviderId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeGitProvider(
          gitProviderId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['GitProviderApi.removeGitProvider']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Set Git provider
     * @summary Set Git provider
     * @param {SetGitProviderConfig} gitProviderConfig Git provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setGitProvider(
      gitProviderConfig: SetGitProviderConfig,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setGitProvider(
        gitProviderConfig,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['GitProviderApi.setGitProvider']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * GitProviderApi - factory interface
 * @export
 */
export const GitProviderApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = GitProviderApiFp(configuration)
  return {
    /**
     * Get Git context
     * @summary Get Git context
     * @param {string} gitUrl Git URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGitContext(
      gitUrl: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GitRepository> {
      return localVarFp
        .getGitContext(gitUrl, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get Git provider
     * @summary Get Git provider
     * @param {string} url Url
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGitProviderForUrl(
      url: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GitProvider> {
      return localVarFp
        .getGitProviderForUrl(url, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get Git provider ID
     * @summary Get Git provider ID
     * @param {string} url Url
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGitProviderIdForUrl(
      url: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .getGitProviderIdForUrl(url, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get Git context
     * @summary Get Git context
     * @param {string} gitProviderId Git Provider Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGitUser(
      gitProviderId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GitUser> {
      return localVarFp
        .getGitUser(gitProviderId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get Git namespaces
     * @summary Get Git namespaces
     * @param {string} gitProviderId Git provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNamespaces(
      gitProviderId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GitNamespace>> {
      return localVarFp
        .getNamespaces(gitProviderId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get Git repository branches
     * @summary Get Git repository branches
     * @param {string} gitProviderId Git provider
     * @param {string} namespaceId Namespace
     * @param {string} repositoryId Repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepoBranches(
      gitProviderId: string,
      namespaceId: string,
      repositoryId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GitBranch>> {
      return localVarFp
        .getRepoBranches(gitProviderId, namespaceId, repositoryId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get Git repository PRs
     * @summary Get Git repository PRs
     * @param {string} gitProviderId Git provider
     * @param {string} namespaceId Namespace
     * @param {string} repositoryId Repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepoPRs(
      gitProviderId: string,
      namespaceId: string,
      repositoryId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GitPullRequest>> {
      return localVarFp
        .getRepoPRs(gitProviderId, namespaceId, repositoryId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get Git repositories
     * @summary Get Git repositories
     * @param {string} gitProviderId Git provider
     * @param {string} namespaceId Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositories(
      gitProviderId: string,
      namespaceId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GitRepository>> {
      return localVarFp
        .getRepositories(gitProviderId, namespaceId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get URL from Git repository
     * @summary Get URL from Git repository
     * @param {GitRepository} repository Git repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUrlFromRepository(
      repository: GitRepository,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<RepositoryUrl> {
      return localVarFp
        .getUrlFromRepository(repository, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List Git providers
     * @summary List Git providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGitProviders(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GitProvider>> {
      return localVarFp
        .listGitProviders(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Remove Git provider
     * @summary Remove Git provider
     * @param {string} gitProviderId Git provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGitProvider(
      gitProviderId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .removeGitProvider(gitProviderId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Set Git provider
     * @summary Set Git provider
     * @param {SetGitProviderConfig} gitProviderConfig Git provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGitProvider(
      gitProviderConfig: SetGitProviderConfig,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .setGitProvider(gitProviderConfig, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * GitProviderApi - object-oriented interface
 * @export
 * @class GitProviderApi
 * @extends {BaseAPI}
 */
export class GitProviderApi extends BaseAPI {
  /**
   * Get Git context
   * @summary Get Git context
   * @param {string} gitUrl Git URL
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitProviderApi
   */
  public getGitContext(gitUrl: string, options?: RawAxiosRequestConfig) {
    return GitProviderApiFp(this.configuration)
      .getGitContext(gitUrl, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get Git provider
   * @summary Get Git provider
   * @param {string} url Url
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitProviderApi
   */
  public getGitProviderForUrl(url: string, options?: RawAxiosRequestConfig) {
    return GitProviderApiFp(this.configuration)
      .getGitProviderForUrl(url, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get Git provider ID
   * @summary Get Git provider ID
   * @param {string} url Url
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitProviderApi
   */
  public getGitProviderIdForUrl(url: string, options?: RawAxiosRequestConfig) {
    return GitProviderApiFp(this.configuration)
      .getGitProviderIdForUrl(url, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get Git context
   * @summary Get Git context
   * @param {string} gitProviderId Git Provider Id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitProviderApi
   */
  public getGitUser(gitProviderId: string, options?: RawAxiosRequestConfig) {
    return GitProviderApiFp(this.configuration)
      .getGitUser(gitProviderId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get Git namespaces
   * @summary Get Git namespaces
   * @param {string} gitProviderId Git provider
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitProviderApi
   */
  public getNamespaces(gitProviderId: string, options?: RawAxiosRequestConfig) {
    return GitProviderApiFp(this.configuration)
      .getNamespaces(gitProviderId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get Git repository branches
   * @summary Get Git repository branches
   * @param {string} gitProviderId Git provider
   * @param {string} namespaceId Namespace
   * @param {string} repositoryId Repository
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitProviderApi
   */
  public getRepoBranches(
    gitProviderId: string,
    namespaceId: string,
    repositoryId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return GitProviderApiFp(this.configuration)
      .getRepoBranches(gitProviderId, namespaceId, repositoryId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get Git repository PRs
   * @summary Get Git repository PRs
   * @param {string} gitProviderId Git provider
   * @param {string} namespaceId Namespace
   * @param {string} repositoryId Repository
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitProviderApi
   */
  public getRepoPRs(
    gitProviderId: string,
    namespaceId: string,
    repositoryId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return GitProviderApiFp(this.configuration)
      .getRepoPRs(gitProviderId, namespaceId, repositoryId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get Git repositories
   * @summary Get Git repositories
   * @param {string} gitProviderId Git provider
   * @param {string} namespaceId Namespace
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitProviderApi
   */
  public getRepositories(
    gitProviderId: string,
    namespaceId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return GitProviderApiFp(this.configuration)
      .getRepositories(gitProviderId, namespaceId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get URL from Git repository
   * @summary Get URL from Git repository
   * @param {GitRepository} repository Git repository
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitProviderApi
   */
  public getUrlFromRepository(
    repository: GitRepository,
    options?: RawAxiosRequestConfig,
  ) {
    return GitProviderApiFp(this.configuration)
      .getUrlFromRepository(repository, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List Git providers
   * @summary List Git providers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitProviderApi
   */
  public listGitProviders(options?: RawAxiosRequestConfig) {
    return GitProviderApiFp(this.configuration)
      .listGitProviders(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Remove Git provider
   * @summary Remove Git provider
   * @param {string} gitProviderId Git provider
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitProviderApi
   */
  public removeGitProvider(
    gitProviderId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return GitProviderApiFp(this.configuration)
      .removeGitProvider(gitProviderId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Set Git provider
   * @summary Set Git provider
   * @param {SetGitProviderConfig} gitProviderConfig Git provider
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GitProviderApi
   */
  public setGitProvider(
    gitProviderConfig: SetGitProviderConfig,
    options?: RawAxiosRequestConfig,
  ) {
    return GitProviderApiFp(this.configuration)
      .setGitProvider(gitProviderConfig, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Delete profile data
     * @summary Delete profile data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProfileData: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/profile`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get profile data
     * @summary Get profile data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfileData: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/profile`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set profile data
     * @summary Set profile data
     * @param {ProfileData} profileData Profile data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setProfileData: async (
      profileData: ProfileData,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'profileData' is not null or undefined
      assertParamExists('setProfileData', 'profileData', profileData)
      const localVarPath = `/profile`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        profileData,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
  return {
    /**
     * Delete profile data
     * @summary Delete profile data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteProfileData(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteProfileData(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProfileApi.deleteProfileData']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get profile data
     * @summary Get profile data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProfileData(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileData(
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProfileApi.getProfileData']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Set profile data
     * @summary Set profile data
     * @param {ProfileData} profileData Profile data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setProfileData(
      profileData: ProfileData,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setProfileData(
        profileData,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProfileApi.setProfileData']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProfileApiFp(configuration)
  return {
    /**
     * Delete profile data
     * @summary Delete profile data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProfileData(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .deleteProfileData(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get profile data
     * @summary Get profile data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfileData(options?: RawAxiosRequestConfig): AxiosPromise<ProfileData> {
      return localVarFp
        .getProfileData(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Set profile data
     * @summary Set profile data
     * @param {ProfileData} profileData Profile data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setProfileData(
      profileData: ProfileData,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .setProfileData(profileData, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
  /**
   * Delete profile data
   * @summary Delete profile data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApi
   */
  public deleteProfileData(options?: RawAxiosRequestConfig) {
    return ProfileApiFp(this.configuration)
      .deleteProfileData(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get profile data
   * @summary Get profile data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApi
   */
  public getProfileData(options?: RawAxiosRequestConfig) {
    return ProfileApiFp(this.configuration)
      .getProfileData(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Set profile data
   * @summary Set profile data
   * @param {ProfileData} profileData Profile data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApi
   */
  public setProfileData(
    profileData: ProfileData,
    options?: RawAxiosRequestConfig,
  ) {
    return ProfileApiFp(this.configuration)
      .setProfileData(profileData, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ProjectConfigApi - axios parameter creator
 * @export
 */
export const ProjectConfigApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Delete project config data
     * @summary Delete project config data
     * @param {string} configName Config name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProjectConfig: async (
      configName: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configName' is not null or undefined
      assertParamExists('deleteProjectConfig', 'configName', configName)
      const localVarPath = `/project-config/{configName}`.replace(
        `{${'configName'}}`,
        encodeURIComponent(String(configName)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get project configs by git url
     * @summary Get project configs by git url
     * @param {string} gitUrl Git URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultProjectConfig: async (
      gitUrl: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'gitUrl' is not null or undefined
      assertParamExists('getDefaultProjectConfig', 'gitUrl', gitUrl)
      const localVarPath = `/project-config/default/{gitUrl}`.replace(
        `{${'gitUrl'}}`,
        encodeURIComponent(String(gitUrl)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get project config data
     * @summary Get project config data
     * @param {string} configName Config name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectConfig: async (
      configName: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configName' is not null or undefined
      assertParamExists('getProjectConfig', 'configName', configName)
      const localVarPath = `/project-config/{configName}`.replace(
        `{${'configName'}}`,
        encodeURIComponent(String(configName)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List project configs
     * @summary List project configs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProjectConfigs: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/project-config`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set project config to default
     * @summary Set project config to default
     * @param {string} configName Config name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setDefaultProjectConfig: async (
      configName: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configName' is not null or undefined
      assertParamExists('setDefaultProjectConfig', 'configName', configName)
      const localVarPath = `/project-config/{configName}/set-default`.replace(
        `{${'configName'}}`,
        encodeURIComponent(String(configName)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set project config data
     * @summary Set project config data
     * @param {CreateProjectConfigDTO} projectConfig Project config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setProjectConfig: async (
      projectConfig: CreateProjectConfigDTO,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectConfig' is not null or undefined
      assertParamExists('setProjectConfig', 'projectConfig', projectConfig)
      const localVarPath = `/project-config`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        projectConfig,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ProjectConfigApi - functional programming interface
 * @export
 */
export const ProjectConfigApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ProjectConfigApiAxiosParamCreator(configuration)
  return {
    /**
     * Delete project config data
     * @summary Delete project config data
     * @param {string} configName Config name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteProjectConfig(
      configName: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteProjectConfig(configName, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProjectConfigApi.deleteProjectConfig']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get project configs by git url
     * @summary Get project configs by git url
     * @param {string} gitUrl Git URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDefaultProjectConfig(
      gitUrl: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectConfig>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDefaultProjectConfig(gitUrl, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProjectConfigApi.getDefaultProjectConfig']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get project config data
     * @summary Get project config data
     * @param {string} configName Config name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProjectConfig(
      configName: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectConfig>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getProjectConfig(configName, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProjectConfigApi.getProjectConfig']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * List project configs
     * @summary List project configs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listProjectConfigs(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ProjectConfig>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listProjectConfigs(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProjectConfigApi.listProjectConfigs']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Set project config to default
     * @summary Set project config to default
     * @param {string} configName Config name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setDefaultProjectConfig(
      configName: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setDefaultProjectConfig(
          configName,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProjectConfigApi.setDefaultProjectConfig']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Set project config data
     * @summary Set project config data
     * @param {CreateProjectConfigDTO} projectConfig Project config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setProjectConfig(
      projectConfig: CreateProjectConfigDTO,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setProjectConfig(projectConfig, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProjectConfigApi.setProjectConfig']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ProjectConfigApi - factory interface
 * @export
 */
export const ProjectConfigApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProjectConfigApiFp(configuration)
  return {
    /**
     * Delete project config data
     * @summary Delete project config data
     * @param {string} configName Config name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProjectConfig(
      configName: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteProjectConfig(configName, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get project configs by git url
     * @summary Get project configs by git url
     * @param {string} gitUrl Git URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultProjectConfig(
      gitUrl: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProjectConfig> {
      return localVarFp
        .getDefaultProjectConfig(gitUrl, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get project config data
     * @summary Get project config data
     * @param {string} configName Config name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectConfig(
      configName: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProjectConfig> {
      return localVarFp
        .getProjectConfig(configName, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List project configs
     * @summary List project configs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProjectConfigs(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ProjectConfig>> {
      return localVarFp
        .listProjectConfigs(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Set project config to default
     * @summary Set project config to default
     * @param {string} configName Config name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setDefaultProjectConfig(
      configName: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .setDefaultProjectConfig(configName, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Set project config data
     * @summary Set project config data
     * @param {CreateProjectConfigDTO} projectConfig Project config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setProjectConfig(
      projectConfig: CreateProjectConfigDTO,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .setProjectConfig(projectConfig, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ProjectConfigApi - object-oriented interface
 * @export
 * @class ProjectConfigApi
 * @extends {BaseAPI}
 */
export class ProjectConfigApi extends BaseAPI {
  /**
   * Delete project config data
   * @summary Delete project config data
   * @param {string} configName Config name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectConfigApi
   */
  public deleteProjectConfig(
    configName: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ProjectConfigApiFp(this.configuration)
      .deleteProjectConfig(configName, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get project configs by git url
   * @summary Get project configs by git url
   * @param {string} gitUrl Git URL
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectConfigApi
   */
  public getDefaultProjectConfig(
    gitUrl: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ProjectConfigApiFp(this.configuration)
      .getDefaultProjectConfig(gitUrl, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get project config data
   * @summary Get project config data
   * @param {string} configName Config name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectConfigApi
   */
  public getProjectConfig(configName: string, options?: RawAxiosRequestConfig) {
    return ProjectConfigApiFp(this.configuration)
      .getProjectConfig(configName, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List project configs
   * @summary List project configs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectConfigApi
   */
  public listProjectConfigs(options?: RawAxiosRequestConfig) {
    return ProjectConfigApiFp(this.configuration)
      .listProjectConfigs(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Set project config to default
   * @summary Set project config to default
   * @param {string} configName Config name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectConfigApi
   */
  public setDefaultProjectConfig(
    configName: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ProjectConfigApiFp(this.configuration)
      .setDefaultProjectConfig(configName, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Set project config data
   * @summary Set project config data
   * @param {CreateProjectConfigDTO} projectConfig Project config
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectConfigApi
   */
  public setProjectConfig(
    projectConfig: CreateProjectConfigDTO,
    options?: RawAxiosRequestConfig,
  ) {
    return ProjectConfigApiFp(this.configuration)
      .setProjectConfig(projectConfig, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ProviderApi - axios parameter creator
 * @export
 */
export const ProviderApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get provider target manifest
     * @summary Get provider target manifest
     * @param {string} provider Provider name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTargetManifest: async (
      provider: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'provider' is not null or undefined
      assertParamExists('getTargetManifest', 'provider', provider)
      const localVarPath = `/provider/{provider}/target-manifest`.replace(
        `{${'provider'}}`,
        encodeURIComponent(String(provider)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Install a provider
     * @summary Install a provider
     * @param {InstallProviderRequest} provider Provider to install
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installProvider: async (
      provider: InstallProviderRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'provider' is not null or undefined
      assertParamExists('installProvider', 'provider', provider)
      const localVarPath = `/provider/install`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        provider,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List providers
     * @summary List providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProviders: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/provider`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Uninstall a provider
     * @summary Uninstall a provider
     * @param {string} provider Provider to uninstall
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uninstallProvider: async (
      provider: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'provider' is not null or undefined
      assertParamExists('uninstallProvider', 'provider', provider)
      const localVarPath = `/provider/{provider}/uninstall`.replace(
        `{${'provider'}}`,
        encodeURIComponent(String(provider)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ProviderApi - functional programming interface
 * @export
 */
export const ProviderApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProviderApiAxiosParamCreator(configuration)
  return {
    /**
     * Get provider target manifest
     * @summary Get provider target manifest
     * @param {string} provider Provider name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTargetManifest(
      provider: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<{ [key: string]: ProviderProviderTargetProperty }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTargetManifest(provider, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProviderApi.getTargetManifest']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Install a provider
     * @summary Install a provider
     * @param {InstallProviderRequest} provider Provider to install
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async installProvider(
      provider: InstallProviderRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.installProvider(
        provider,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProviderApi.installProvider']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * List providers
     * @summary List providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listProviders(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<Provider>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listProviders(
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProviderApi.listProviders']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Uninstall a provider
     * @summary Uninstall a provider
     * @param {string} provider Provider to uninstall
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uninstallProvider(
      provider: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.uninstallProvider(provider, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProviderApi.uninstallProvider']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ProviderApi - factory interface
 * @export
 */
export const ProviderApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProviderApiFp(configuration)
  return {
    /**
     * Get provider target manifest
     * @summary Get provider target manifest
     * @param {string} provider Provider name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTargetManifest(
      provider: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<{ [key: string]: ProviderProviderTargetProperty }> {
      return localVarFp
        .getTargetManifest(provider, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Install a provider
     * @summary Install a provider
     * @param {InstallProviderRequest} provider Provider to install
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installProvider(
      provider: InstallProviderRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .installProvider(provider, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List providers
     * @summary List providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProviders(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<Provider>> {
      return localVarFp
        .listProviders(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Uninstall a provider
     * @summary Uninstall a provider
     * @param {string} provider Provider to uninstall
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uninstallProvider(
      provider: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .uninstallProvider(provider, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ProviderApi - object-oriented interface
 * @export
 * @class ProviderApi
 * @extends {BaseAPI}
 */
export class ProviderApi extends BaseAPI {
  /**
   * Get provider target manifest
   * @summary Get provider target manifest
   * @param {string} provider Provider name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProviderApi
   */
  public getTargetManifest(provider: string, options?: RawAxiosRequestConfig) {
    return ProviderApiFp(this.configuration)
      .getTargetManifest(provider, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Install a provider
   * @summary Install a provider
   * @param {InstallProviderRequest} provider Provider to install
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProviderApi
   */
  public installProvider(
    provider: InstallProviderRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ProviderApiFp(this.configuration)
      .installProvider(provider, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List providers
   * @summary List providers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProviderApi
   */
  public listProviders(options?: RawAxiosRequestConfig) {
    return ProviderApiFp(this.configuration)
      .listProviders(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Uninstall a provider
   * @summary Uninstall a provider
   * @param {string} provider Provider to uninstall
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProviderApi
   */
  public uninstallProvider(provider: string, options?: RawAxiosRequestConfig) {
    return ProviderApiFp(this.configuration)
      .uninstallProvider(provider, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ServerApi - axios parameter creator
 * @export
 */
export const ServerApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Generate a new authentication key
     * @summary Generate a new authentication key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateNetworkKey: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/server/network-key`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the server configuration
     * @summary Get the server configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfig: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/server/config`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set the server configuration
     * @summary Set the server configuration
     * @param {ServerConfig} config Server configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setConfig: async (
      config: ServerConfig,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'config' is not null or undefined
      assertParamExists('setConfig', 'config', config)
      const localVarPath = `/server/config`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        config,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ServerApiAxiosParamCreator(configuration)
  return {
    /**
     * Generate a new authentication key
     * @summary Generate a new authentication key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateNetworkKey(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkKey>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.generateNetworkKey(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.generateNetworkKey']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get the server configuration
     * @summary Get the server configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConfig(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerConfig>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.getConfig']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Set the server configuration
     * @summary Set the server configuration
     * @param {ServerConfig} config Server configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setConfig(
      config: ServerConfig,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerConfig>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setConfig(
        config,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.setConfig']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ServerApiFp(configuration)
  return {
    /**
     * Generate a new authentication key
     * @summary Generate a new authentication key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateNetworkKey(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<NetworkKey> {
      return localVarFp
        .generateNetworkKey(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get the server configuration
     * @summary Get the server configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfig(options?: RawAxiosRequestConfig): AxiosPromise<ServerConfig> {
      return localVarFp
        .getConfig(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Set the server configuration
     * @summary Set the server configuration
     * @param {ServerConfig} config Server configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setConfig(
      config: ServerConfig,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ServerConfig> {
      return localVarFp
        .setConfig(config, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI {
  /**
   * Generate a new authentication key
   * @summary Generate a new authentication key
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public generateNetworkKey(options?: RawAxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .generateNetworkKey(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the server configuration
   * @summary Get the server configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public getConfig(options?: RawAxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .getConfig(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Set the server configuration
   * @summary Set the server configuration
   * @param {ServerConfig} config Server configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public setConfig(config: ServerConfig, options?: RawAxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .setConfig(config, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TargetApi - axios parameter creator
 * @export
 */
export const TargetApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * List targets
     * @summary List targets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTargets: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/target`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Remove a target
     * @summary Remove a target
     * @param {string} target Target name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeTarget: async (
      target: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'target' is not null or undefined
      assertParamExists('removeTarget', 'target', target)
      const localVarPath = `/target/{target}`.replace(
        `{${'target'}}`,
        encodeURIComponent(String(target)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set a target
     * @summary Set a target
     * @param {ProviderTarget} target Target to set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTarget: async (
      target: ProviderTarget,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'target' is not null or undefined
      assertParamExists('setTarget', 'target', target)
      const localVarPath = `/target`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        target,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TargetApi - functional programming interface
 * @export
 */
export const TargetApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TargetApiAxiosParamCreator(configuration)
  return {
    /**
     * List targets
     * @summary List targets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTargets(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ProviderTarget>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTargets(
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TargetApi.listTargets']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Remove a target
     * @summary Remove a target
     * @param {string} target Target name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeTarget(
      target: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeTarget(
        target,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TargetApi.removeTarget']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Set a target
     * @summary Set a target
     * @param {ProviderTarget} target Target to set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setTarget(
      target: ProviderTarget,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setTarget(
        target,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TargetApi.setTarget']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * TargetApi - factory interface
 * @export
 */
export const TargetApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TargetApiFp(configuration)
  return {
    /**
     * List targets
     * @summary List targets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTargets(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ProviderTarget>> {
      return localVarFp
        .listTargets(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Remove a target
     * @summary Remove a target
     * @param {string} target Target name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeTarget(
      target: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .removeTarget(target, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Set a target
     * @summary Set a target
     * @param {ProviderTarget} target Target to set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTarget(
      target: ProviderTarget,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .setTarget(target, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TargetApi - object-oriented interface
 * @export
 * @class TargetApi
 * @extends {BaseAPI}
 */
export class TargetApi extends BaseAPI {
  /**
   * List targets
   * @summary List targets
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TargetApi
   */
  public listTargets(options?: RawAxiosRequestConfig) {
    return TargetApiFp(this.configuration)
      .listTargets(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Remove a target
   * @summary Remove a target
   * @param {string} target Target name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TargetApi
   */
  public removeTarget(target: string, options?: RawAxiosRequestConfig) {
    return TargetApiFp(this.configuration)
      .removeTarget(target, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Set a target
   * @summary Set a target
   * @param {ProviderTarget} target Target to set
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TargetApi
   */
  public setTarget(target: ProviderTarget, options?: RawAxiosRequestConfig) {
    return TargetApiFp(this.configuration)
      .setTarget(target, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * WorkspaceApi - axios parameter creator
 * @export
 */
export const WorkspaceApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Create a workspace
     * @summary Create a workspace
     * @param {CreateWorkspaceDTO} workspace Create workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkspace: async (
      workspace: CreateWorkspaceDTO,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspace' is not null or undefined
      assertParamExists('createWorkspace', 'workspace', workspace)
      const localVarPath = `/workspace`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        workspace,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get workspace info
     * @summary Get workspace info
     * @param {string} workspaceId Workspace ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkspace: async (
      workspaceId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('getWorkspace', 'workspaceId', workspaceId)
      const localVarPath = `/workspace/{workspaceId}`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List workspaces
     * @summary List workspaces
     * @param {boolean} [verbose] Verbose
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkspaces: async (
      verbose?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/workspace`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      if (verbose !== undefined) {
        localVarQueryParameter['verbose'] = verbose
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Remove workspace
     * @summary Remove workspace
     * @param {string} workspaceId Workspace ID
     * @param {boolean} [force] Force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeWorkspace: async (
      workspaceId: string,
      force?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('removeWorkspace', 'workspaceId', workspaceId)
      const localVarPath = `/workspace/{workspaceId}`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      if (force !== undefined) {
        localVarQueryParameter['force'] = force
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set project state
     * @summary Set project state
     * @param {string} workspaceId Workspace ID or Name
     * @param {string} projectId Project ID
     * @param {SetProjectState} setState Set State
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setProjectState: async (
      workspaceId: string,
      projectId: string,
      setState: SetProjectState,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('setProjectState', 'workspaceId', workspaceId)
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('setProjectState', 'projectId', projectId)
      // verify required parameter 'setState' is not null or undefined
      assertParamExists('setProjectState', 'setState', setState)
      const localVarPath = `/workspace/{workspaceId}/{projectId}/state`
        .replace(`{${'workspaceId'}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        setState,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Start project
     * @summary Start project
     * @param {string} workspaceId Workspace ID or Name
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startProject: async (
      workspaceId: string,
      projectId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('startProject', 'workspaceId', workspaceId)
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('startProject', 'projectId', projectId)
      const localVarPath = `/workspace/{workspaceId}/{projectId}/start`
        .replace(`{${'workspaceId'}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Start workspace
     * @summary Start workspace
     * @param {string} workspaceId Workspace ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startWorkspace: async (
      workspaceId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('startWorkspace', 'workspaceId', workspaceId)
      const localVarPath = `/workspace/{workspaceId}/start`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Stop project
     * @summary Stop project
     * @param {string} workspaceId Workspace ID or Name
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopProject: async (
      workspaceId: string,
      projectId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('stopProject', 'workspaceId', workspaceId)
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('stopProject', 'projectId', projectId)
      const localVarPath = `/workspace/{workspaceId}/{projectId}/stop`
        .replace(`{${'workspaceId'}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Stop workspace
     * @summary Stop workspace
     * @param {string} workspaceId Workspace ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopWorkspace: async (
      workspaceId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceId' is not null or undefined
      assertParamExists('stopWorkspace', 'workspaceId', workspaceId)
      const localVarPath = `/workspace/{workspaceId}/stop`.replace(
        `{${'workspaceId'}}`,
        encodeURIComponent(String(workspaceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * WorkspaceApi - functional programming interface
 * @export
 */
export const WorkspaceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WorkspaceApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a workspace
     * @summary Create a workspace
     * @param {CreateWorkspaceDTO} workspace Create workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createWorkspace(
      workspace: CreateWorkspaceDTO,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspace(
        workspace,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WorkspaceApi.createWorkspace']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get workspace info
     * @summary Get workspace info
     * @param {string} workspaceId Workspace ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWorkspace(
      workspaceId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspace(
        workspaceId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WorkspaceApi.getWorkspace']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * List workspaces
     * @summary List workspaces
     * @param {boolean} [verbose] Verbose
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listWorkspaces(
      verbose?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<WorkspaceDTO>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkspaces(
        verbose,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WorkspaceApi.listWorkspaces']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Remove workspace
     * @summary Remove workspace
     * @param {string} workspaceId Workspace ID
     * @param {boolean} [force] Force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeWorkspace(
      workspaceId: string,
      force?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeWorkspace(
        workspaceId,
        force,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WorkspaceApi.removeWorkspace']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Set project state
     * @summary Set project state
     * @param {string} workspaceId Workspace ID or Name
     * @param {string} projectId Project ID
     * @param {SetProjectState} setState Set State
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setProjectState(
      workspaceId: string,
      projectId: string,
      setState: SetProjectState,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setProjectState(
        workspaceId,
        projectId,
        setState,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WorkspaceApi.setProjectState']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Start project
     * @summary Start project
     * @param {string} workspaceId Workspace ID or Name
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startProject(
      workspaceId: string,
      projectId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.startProject(
        workspaceId,
        projectId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WorkspaceApi.startProject']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Start workspace
     * @summary Start workspace
     * @param {string} workspaceId Workspace ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startWorkspace(
      workspaceId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.startWorkspace(
        workspaceId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WorkspaceApi.startWorkspace']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Stop project
     * @summary Stop project
     * @param {string} workspaceId Workspace ID or Name
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stopProject(
      workspaceId: string,
      projectId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.stopProject(
        workspaceId,
        projectId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WorkspaceApi.stopProject']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Stop workspace
     * @summary Stop workspace
     * @param {string} workspaceId Workspace ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stopWorkspace(
      workspaceId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.stopWorkspace(
        workspaceId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WorkspaceApi.stopWorkspace']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * WorkspaceApi - factory interface
 * @export
 */
export const WorkspaceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = WorkspaceApiFp(configuration)
  return {
    /**
     * Create a workspace
     * @summary Create a workspace
     * @param {CreateWorkspaceDTO} workspace Create workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkspace(
      workspace: CreateWorkspaceDTO,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Workspace> {
      return localVarFp
        .createWorkspace(workspace, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get workspace info
     * @summary Get workspace info
     * @param {string} workspaceId Workspace ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkspace(
      workspaceId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WorkspaceDTO> {
      return localVarFp
        .getWorkspace(workspaceId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List workspaces
     * @summary List workspaces
     * @param {boolean} [verbose] Verbose
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkspaces(
      verbose?: boolean,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<WorkspaceDTO>> {
      return localVarFp
        .listWorkspaces(verbose, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Remove workspace
     * @summary Remove workspace
     * @param {string} workspaceId Workspace ID
     * @param {boolean} [force] Force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeWorkspace(
      workspaceId: string,
      force?: boolean,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .removeWorkspace(workspaceId, force, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Set project state
     * @summary Set project state
     * @param {string} workspaceId Workspace ID or Name
     * @param {string} projectId Project ID
     * @param {SetProjectState} setState Set State
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setProjectState(
      workspaceId: string,
      projectId: string,
      setState: SetProjectState,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .setProjectState(workspaceId, projectId, setState, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Start project
     * @summary Start project
     * @param {string} workspaceId Workspace ID or Name
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startProject(
      workspaceId: string,
      projectId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .startProject(workspaceId, projectId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Start workspace
     * @summary Start workspace
     * @param {string} workspaceId Workspace ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startWorkspace(
      workspaceId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .startWorkspace(workspaceId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Stop project
     * @summary Stop project
     * @param {string} workspaceId Workspace ID or Name
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopProject(
      workspaceId: string,
      projectId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .stopProject(workspaceId, projectId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Stop workspace
     * @summary Stop workspace
     * @param {string} workspaceId Workspace ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopWorkspace(
      workspaceId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .stopWorkspace(workspaceId, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * WorkspaceApi - object-oriented interface
 * @export
 * @class WorkspaceApi
 * @extends {BaseAPI}
 */
export class WorkspaceApi extends BaseAPI {
  /**
   * Create a workspace
   * @summary Create a workspace
   * @param {CreateWorkspaceDTO} workspace Create workspace
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspaceApi
   */
  public createWorkspace(
    workspace: CreateWorkspaceDTO,
    options?: RawAxiosRequestConfig,
  ) {
    return WorkspaceApiFp(this.configuration)
      .createWorkspace(workspace, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get workspace info
   * @summary Get workspace info
   * @param {string} workspaceId Workspace ID or Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspaceApi
   */
  public getWorkspace(workspaceId: string, options?: RawAxiosRequestConfig) {
    return WorkspaceApiFp(this.configuration)
      .getWorkspace(workspaceId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List workspaces
   * @summary List workspaces
   * @param {boolean} [verbose] Verbose
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspaceApi
   */
  public listWorkspaces(verbose?: boolean, options?: RawAxiosRequestConfig) {
    return WorkspaceApiFp(this.configuration)
      .listWorkspaces(verbose, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Remove workspace
   * @summary Remove workspace
   * @param {string} workspaceId Workspace ID
   * @param {boolean} [force] Force
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspaceApi
   */
  public removeWorkspace(
    workspaceId: string,
    force?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return WorkspaceApiFp(this.configuration)
      .removeWorkspace(workspaceId, force, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Set project state
   * @summary Set project state
   * @param {string} workspaceId Workspace ID or Name
   * @param {string} projectId Project ID
   * @param {SetProjectState} setState Set State
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspaceApi
   */
  public setProjectState(
    workspaceId: string,
    projectId: string,
    setState: SetProjectState,
    options?: RawAxiosRequestConfig,
  ) {
    return WorkspaceApiFp(this.configuration)
      .setProjectState(workspaceId, projectId, setState, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Start project
   * @summary Start project
   * @param {string} workspaceId Workspace ID or Name
   * @param {string} projectId Project ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspaceApi
   */
  public startProject(
    workspaceId: string,
    projectId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return WorkspaceApiFp(this.configuration)
      .startProject(workspaceId, projectId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Start workspace
   * @summary Start workspace
   * @param {string} workspaceId Workspace ID or Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspaceApi
   */
  public startWorkspace(workspaceId: string, options?: RawAxiosRequestConfig) {
    return WorkspaceApiFp(this.configuration)
      .startWorkspace(workspaceId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Stop project
   * @summary Stop project
   * @param {string} workspaceId Workspace ID or Name
   * @param {string} projectId Project ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspaceApi
   */
  public stopProject(
    workspaceId: string,
    projectId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return WorkspaceApiFp(this.configuration)
      .stopProject(workspaceId, projectId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Stop workspace
   * @summary Stop workspace
   * @param {string} workspaceId Workspace ID or Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspaceApi
   */
  public stopWorkspace(workspaceId: string, options?: RawAxiosRequestConfig) {
    return WorkspaceApiFp(this.configuration)
      .stopWorkspace(workspaceId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
